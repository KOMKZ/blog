# 数据库读现象，事务隔离级别，锁机制

## 读现象

### 脏读

说明：

1. 事务A读取了一个值
2. 事务B修改里这个值
3. 事务A又读取了这个值（a）

事务B最终没有提交这次事务，但是事务A拿了这个值去使用了。
上面过程中a这个操作就是一个脏读
注：
mysql的默认隔离级别能够避免脏读

不可重复读
1. 事务A执行到步骤1的时候读取a=1值，
2. 事务B修改了a=0值并提交
3. 事务A继续利用a=0值进行运算/或者重新读取出这个值（a）
4. 事务A进行了一次错误的运算
  上面过程中就发生了不可重复读，在3这个操作中，这个值是不可靠的。比如1这个操作读取出a=1代表可以退款，但是到了步骤3的时候其实a=0了，实际是不能进行退款的。所以这种读取是错误的，而且容易发生错误。
  发生的场景：
  比如一个退款请求过来，订单的退款状态是1代表能够退款，处理完成之后变成0代表不能退款。
  但是如果两个请求同时过来操作同个订单，他们获取到的退款状态都是1,最终执行了两次退款。

幻读
1. 事务A读取范围A的数据行
2. 事务B在范围A中插入数据行并且提交
3. 事务A完成任务之后，发现新行居然没有被处理
  上面过程发生了幻读，幻读的根本原因都是其他事务对符合条件的数据进行提交。

事务隔离级别：
我们知道事务的隔离性定义了事务之间不应该相互影响，但是数据永远只有一份，在某个过程中，总是会发生改变，也就是并发总发生变化时，此时数据在不同的事务中的状态应该是怎样的，这里设置不同的表现，也就是事务的隔离级别。定义不同的隔离级别能够防止各种读现象的发生。提高隔离级别可以通过锁机制和多版本控制来实现。

锁机制：
上述过程谈到了锁机制，是用于提高事务隔离级别的一种方法。

mysql行级锁：
对当前操作的数据行进行加锁，粒度最小，开销最大，可以选择共享锁还有排他锁。

mysql表级锁：
对操作当前的数据表进行加锁，粒度最大，开销小，可以选择共享锁还有排他锁。

共享锁：
加了共享锁的数据只能被读取，不能被修改，同时只能在加共享锁，不能加其他锁，能修改的时候必须是
所有的共享锁都被释放的时候。事务被提交的时候就当作完成，该事务的共享锁就会被释放。查询出的数据如果有
排他锁，则不能加共享锁，申请失败，阻塞等待释放。
SELECT ... LOCK IN SHARE MODE;

排他锁：
事务对数据加了排他锁，则限定了其他的事务不能加任何锁，只有等待释放。拥有排她锁的数据不能够被读取，只有等到排他锁释放的时候其他事务才能够读取。
SELECT ... FOR UPDATE;



数据库支持锁的情况：
MyISAM和MEMORY采用表级锁(table-level locking)
BDB采用页面锁(page-level locking)或表级锁，默认为页面锁
InnoDB支持行级锁(row-level locking)和表级锁,默认为行级锁
InnoDB这种行锁实现特点意味着：只有通过索引条件检索数据，InnoDB才使用行级锁，否则，InnoDB将使用表锁！

隔离级别，未提交读：
事务A能够读取到另外一个事务没有提交的变动，也就是会发生脏读，不可重复读，幻读。
未提交读在修改的时候会对数据进行加共享锁。这种特性的表现是：
假设一个事务有如下步骤：
1. 读取
2. 更新数据
3. 计算（耗时3秒）
  那么如果未提交读呃两个事务过来，A事务执行到更新数据时会加共享锁，该锁必须等到A事务结束时才能释放，这将导致B事务执行到步骤2的时候将被阻塞住。

隔离级别，提交读：
事务A不能够读取到事务B未提交修改的数据。
具体实现，事务在读取到事务的时候加入共享锁，读取完毕释放共享锁。修改的时候增加排他锁，事务结束的时候释放排他锁。这种特性的表现是：
1. 事务A在读取该数据的时候，事务B都可以读取该数据，因为读取的瞬间不可能发生数据的改变，共享锁的作用，不能修改，所以读取完的数据都是可靠的。
2. 事务A/B其中一个如果对该数据进行修改，因为修改会增加排他锁，所以任何的读取该数据都会被阻塞，处理事务本身。
3. 所以在事务修改完成之后其他事务读取出来的数据都是可靠的。这里就可以避免脏读的现象。
上面看来，提交读已经解决了脏读的问题（读取到的数据可靠且已经提交），但是是否解决了不可重复读呢？不可重复读的现象是说读取出的数据在一个事务过程中存在多种可能，因为其他事务提交的修改。上述过程中，对于数据A的读取，在A数据被修改的过程中被提交，导致接下来读取出的数据A不同，所以发生了不可重复读，所以提交读并没有解决不可重复读的问题。

隔离级别，可重复读：
就是数据在事务过程中可以重复读，为了实现让事务在整个过程中读取都是一致的情况，所以要保证的事情就是，别人绝对不能修改这个数据（解决不可重复读的问题），我修改这个数据的时候别人不能读取（否则别人就会脏读）。
实现的话也很好做，只要对数据进行读取时候加入共享锁，修改的时候加入排他锁，全部等到事务结束的时候再释放。


问题解决记录：
业务描述：
1. 读取一个订单，判断订单状态是可以退款
2. 执行账户余额变动，修改订单状态
3. 提交事务
上述过程中，mysql默认的事务隔离级别是可重复读，





